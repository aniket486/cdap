/*
 * Copyright Â© 2018 Cask Data, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package co.cask.cdap.lineage.field;

import co.cask.cdap.api.lineage.field.EndPoint;
import co.cask.cdap.api.lineage.field.InputField;
import co.cask.cdap.api.lineage.field.Operation;
import co.cask.cdap.api.lineage.field.ReadOperation;
import co.cask.cdap.api.lineage.field.TransformOperation;
import co.cask.cdap.api.lineage.field.WriteOperation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Represents field lineage information in graph format for the operations provided.
 * Field lineage graph consists of set of {@link Node}s and connections between them
 * represented by {@link Edge}. Node in the graph can represent {@link EndPoint},
 * {@link Operation}, or simply field with its origin.
 *
 * Complete path from source EndPoint to the destination EndPoint will at least contain 6 nodes.
 * First node represents the source EndPoint. Second node represents the READ operation on the EndPoint.
 * Third node represents the field generated by the READ operation. Similarly for the destination side,
 * second node from last represents the field which is going to be written, first node from the last
 * represents the WRITE operation and last node represents the EndPoint.
 *
 * Edges do not carry any additional weightage apart from connection between the nodes.
 */
class FieldLineageGraph {
  // Map of node to its inputs
  private final Map<Node, Set<Node>> inputs;

  // Map of node to its outputs
  private final Map<Node, Set<Node>> outputs;

  // set of EndPointNode which are also source in a path
  private final Set<EndPointNode> sources;

  // set of EndPointNode which are also destination in a path
  private final Set<EndPointNode> destinations;

  // all nodes in the graph
  private final Set<Node> nodes;

  // Single list of nodes represent the individual path.
  // All linearized paths in the graph from source to destinations are stored in allPaths.
  private List<List<Node>> allPaths;

  FieldLineageGraph(Set<Operation> operations) {
    Set<Edge> edges = new HashSet<>();
    this.sources = new HashSet<>();
    this.destinations = new HashSet<>();
    this.nodes = new HashSet<>();
    for (Operation op : operations) {
      switch (op.getType()) {
        case READ:
          ReadOperation read = (ReadOperation) op;
          sources.add(new EndPointNode(read.getSource()));
          edges.add(new Edge(new EndPointNode(read.getSource()), new OperationNode(op)));
          for (String output : read.getOutputs()) {
            edges.add(new Edge(new OperationNode(op), new FieldNode(read.getName(), output)));
          }
          break;
        case WRITE:
          WriteOperation write = (WriteOperation) op;
          destinations.add(new EndPointNode(write.getDestination()));
          edges.add(new Edge(new OperationNode(op), new EndPointNode(write.getDestination())));
          for (InputField field : write.getInputs()) {
            edges.add(new Edge(new FieldNode(field.getOrigin(), field.getName()), new OperationNode(op)));
          }
          break;
        case TRANSFORM:
          TransformOperation transform = (TransformOperation) op;
          for (InputField field : transform.getInputs()) {
            edges.add(new Edge(new FieldNode(field.getOrigin(), field.getName()), new OperationNode(op)));
          }
          for (String output : transform.getOutputs()) {
            edges.add(new Edge(new OperationNode(op), new FieldNode(op.getName(), output)));
          }
          break;
      }
    }

    for (Edge edge : edges) {
      nodes.add(edge.getSource());
      nodes.add(edge.getDestination());
    }

    this.inputs = new HashMap<>();
    this.outputs = new HashMap<>();

    for (Edge edge : edges) {
      Set<Node> nodeInputs = inputs.computeIfAbsent(edge.getDestination(), k -> new HashSet<>());
      nodeInputs.add(edge.getSource());

      Set<Node> nodeOutputs = outputs.computeIfAbsent(edge.getSource(), k -> new HashSet<>());
      nodeOutputs.add(edge.getDestination());
    }
  }

  /**
   * @return the set of nodes which are inputs to given node in the graph
   */
  private Set<Node> getInputs(Node node) {
    return inputs.get(node);
  }

  /**
   * @return the set of nodes which are outputs from given node in the graph
   */
  private Set<Node> getOutputs(Node node) {
    return outputs.get(node);
  }

  /**
   * @return all paths in the graph. Each path is linearized list of nodes from source to destination.
   */
  List<List<Node>> getAllPaths() {
    if (allPaths == null) {
      allPaths = new ArrayList<>();
      for (Node source : sources) {
        dfs(source, new ArrayList<>(), allPaths);
      }
    }
    return allPaths;
  }

  private void dfs(Node node, List<Node> currentPath, List<List<Node>> allPaths) {
    currentPath.add(node);
    Set<Node> outputs = getOutputs(node);
    if (outputs == null || outputs.isEmpty()) {
      allPaths.add(currentPath);
      return;
    }

    for (Node output : outputs) {
      List<Node> prefixList = new ArrayList<>(currentPath);
      dfs(output, prefixList, allPaths);
    }
  }
}
